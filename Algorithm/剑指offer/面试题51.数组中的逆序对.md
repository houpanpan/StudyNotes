### 面试题51.  数组中的逆序对

题目:
<https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/>


难度:   困难


**方法一：普通排序**
```python
class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        """
        :type nums: List[int]
        :rtype: int
        """
        count = 0
        for item in sorted(nums):
            count += nums.index(item)
            nums.remove(item)

        # 牛客网需要模1000000007，它是最小的十位质数。模它，可以保证值永远在int的范围内
        # return count % 1000000007 

        # leetcode不要模1000000007
        return count 
```


**方法一：归并排序**
```python
class Solution:
    def reversePairs(self, nums: List[int]) -> int:
class Solution:
    def reversePairs(self, nums) -> int:
        """
        :type nums: List[int]
        :rtype: int
        """

        self.count = 0

        def MergeSort(lists):

            if len(lists) <= 1:
                return lists

            num = int(len(lists) / 2)
            left = MergeSort(lists[:num])
            right = MergeSort(lists[num:])
            r, l = 0, 0
            result = []
            while l < len(left) and r < len(right):
                if left[l] <= right[r]:
                    result.append(left[l])
                    l += 1
                else:
                    result.append(right[r])
                    r += 1
                    self.count += len(left) - l
                    # print('count: ', self.count)
            result += right[r:]
            result += left[l:]

            return result

        MergeSort(nums)
        return self.count
```